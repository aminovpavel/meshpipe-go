// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: proto/meshpipe/v1/data.proto

package grpcv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MeshpipeData_GetDashboardStats_FullMethodName        = "/meshpipe.v1.MeshpipeData/GetDashboardStats"
	MeshpipeData_ListPackets_FullMethodName              = "/meshpipe.v1.MeshpipeData/ListPackets"
	MeshpipeData_StreamPackets_FullMethodName            = "/meshpipe.v1.MeshpipeData/StreamPackets"
	MeshpipeData_ListNodes_FullMethodName                = "/meshpipe.v1.MeshpipeData/ListNodes"
	MeshpipeData_GetNode_FullMethodName                  = "/meshpipe.v1.MeshpipeData/GetNode"
	MeshpipeData_GetGatewayStats_FullMethodName          = "/meshpipe.v1.MeshpipeData/GetGatewayStats"
	MeshpipeData_ListLinks_FullMethodName                = "/meshpipe.v1.MeshpipeData/ListLinks"
	MeshpipeData_ListTraceroutes_FullMethodName          = "/meshpipe.v1.MeshpipeData/ListTraceroutes"
	MeshpipeData_ListRangeTests_FullMethodName           = "/meshpipe.v1.MeshpipeData/ListRangeTests"
	MeshpipeData_ListStoreForward_FullMethodName         = "/meshpipe.v1.MeshpipeData/ListStoreForward"
	MeshpipeData_ListPaxcounter_FullMethodName           = "/meshpipe.v1.MeshpipeData/ListPaxcounter"
	MeshpipeData_ListNodeLocations_FullMethodName        = "/meshpipe.v1.MeshpipeData/ListNodeLocations"
	MeshpipeData_GetChatWindow_FullMethodName            = "/meshpipe.v1.MeshpipeData/GetChatWindow"
	MeshpipeData_GetNodeAnalytics_FullMethodName         = "/meshpipe.v1.MeshpipeData/GetNodeAnalytics"
	MeshpipeData_GetGatewayOverview_FullMethodName       = "/meshpipe.v1.MeshpipeData/GetGatewayOverview"
	MeshpipeData_GetNetworkTopology_FullMethodName       = "/meshpipe.v1.MeshpipeData/GetNetworkTopology"
	MeshpipeData_GetLongestLinksAnalysis_FullMethodName  = "/meshpipe.v1.MeshpipeData/GetLongestLinksAnalysis"
	MeshpipeData_GetGatewayComparison_FullMethodName     = "/meshpipe.v1.MeshpipeData/GetGatewayComparison"
	MeshpipeData_ListGatewayCandidates_FullMethodName    = "/meshpipe.v1.MeshpipeData/ListGatewayCandidates"
	MeshpipeData_GetAnalyticsSummary_FullMethodName      = "/meshpipe.v1.MeshpipeData/GetAnalyticsSummary"
	MeshpipeData_ListTraceroutePackets_FullMethodName    = "/meshpipe.v1.MeshpipeData/ListTraceroutePackets"
	MeshpipeData_GetTracerouteDetails_FullMethodName     = "/meshpipe.v1.MeshpipeData/GetTracerouteDetails"
	MeshpipeData_ListTracerouteHops_FullMethodName       = "/meshpipe.v1.MeshpipeData/ListTracerouteHops"
	MeshpipeData_GetTracerouteGraph_FullMethodName       = "/meshpipe.v1.MeshpipeData/GetTracerouteGraph"
	MeshpipeData_ListNodeDirectReceptions_FullMethodName = "/meshpipe.v1.MeshpipeData/ListNodeDirectReceptions"
	MeshpipeData_ListNodeNames_FullMethodName            = "/meshpipe.v1.MeshpipeData/ListNodeNames"
	MeshpipeData_ListPrimaryChannels_FullMethodName      = "/meshpipe.v1.MeshpipeData/ListPrimaryChannels"
	MeshpipeData_Healthz_FullMethodName                  = "/meshpipe.v1.MeshpipeData/Healthz"
	MeshpipeData_GetVersion_FullMethodName               = "/meshpipe.v1.MeshpipeData/GetVersion"
)

// MeshpipeDataClient is the client API for MeshpipeData service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MeshpipeDataClient interface {
	GetDashboardStats(ctx context.Context, in *DashboardRequest, opts ...grpc.CallOption) (*DashboardResponse, error)
	ListPackets(ctx context.Context, in *ListPacketsRequest, opts ...grpc.CallOption) (*ListPacketsResponse, error)
	StreamPackets(ctx context.Context, in *ListPacketsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Packet], error)
	ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (*ListNodesResponse, error)
	GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*GetNodeResponse, error)
	GetGatewayStats(ctx context.Context, in *GatewayFilter, opts ...grpc.CallOption) (*GatewayStatsResponse, error)
	ListLinks(ctx context.Context, in *ListLinksRequest, opts ...grpc.CallOption) (*ListLinksResponse, error)
	ListTraceroutes(ctx context.Context, in *ListTraceroutesRequest, opts ...grpc.CallOption) (*ListTraceroutesResponse, error)
	ListRangeTests(ctx context.Context, in *ListRangeTestsRequest, opts ...grpc.CallOption) (*ListRangeTestsResponse, error)
	ListStoreForward(ctx context.Context, in *ListStoreForwardRequest, opts ...grpc.CallOption) (*ListStoreForwardResponse, error)
	ListPaxcounter(ctx context.Context, in *ListPaxcounterRequest, opts ...grpc.CallOption) (*ListPaxcounterResponse, error)
	ListNodeLocations(ctx context.Context, in *ListNodeLocationsRequest, opts ...grpc.CallOption) (*ListNodeLocationsResponse, error)
	GetChatWindow(ctx context.Context, in *GetChatWindowRequest, opts ...grpc.CallOption) (*GetChatWindowResponse, error)
	GetNodeAnalytics(ctx context.Context, in *GetNodeAnalyticsRequest, opts ...grpc.CallOption) (*GetNodeAnalyticsResponse, error)
	GetGatewayOverview(ctx context.Context, in *GetGatewayOverviewRequest, opts ...grpc.CallOption) (*GetGatewayOverviewResponse, error)
	GetNetworkTopology(ctx context.Context, in *NetworkTopologyRequest, opts ...grpc.CallOption) (*NetworkTopologyResponse, error)
	GetLongestLinksAnalysis(ctx context.Context, in *LongestLinksRequest, opts ...grpc.CallOption) (*LongestLinksResponse, error)
	GetGatewayComparison(ctx context.Context, in *GatewayComparisonRequest, opts ...grpc.CallOption) (*GatewayComparisonResponse, error)
	ListGatewayCandidates(ctx context.Context, in *GatewayCandidatesRequest, opts ...grpc.CallOption) (*GatewayCandidatesResponse, error)
	GetAnalyticsSummary(ctx context.Context, in *GetAnalyticsSummaryRequest, opts ...grpc.CallOption) (*GetAnalyticsSummaryResponse, error)
	ListTraceroutePackets(ctx context.Context, in *ListTraceroutePacketsRequest, opts ...grpc.CallOption) (*ListTraceroutePacketsResponse, error)
	GetTracerouteDetails(ctx context.Context, in *GetTracerouteDetailsRequest, opts ...grpc.CallOption) (*GetTracerouteDetailsResponse, error)
	ListTracerouteHops(ctx context.Context, in *ListTracerouteHopsRequest, opts ...grpc.CallOption) (*ListTracerouteHopsResponse, error)
	GetTracerouteGraph(ctx context.Context, in *TracerouteGraphRequest, opts ...grpc.CallOption) (*TracerouteGraphResponse, error)
	ListNodeDirectReceptions(ctx context.Context, in *ListNodeDirectReceptionsRequest, opts ...grpc.CallOption) (*ListNodeDirectReceptionsResponse, error)
	ListNodeNames(ctx context.Context, in *ListNodeNamesRequest, opts ...grpc.CallOption) (*ListNodeNamesResponse, error)
	ListPrimaryChannels(ctx context.Context, in *ListPrimaryChannelsRequest, opts ...grpc.CallOption) (*ListPrimaryChannelsResponse, error)
	Healthz(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	GetVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*VersionResponse, error)
}

type meshpipeDataClient struct {
	cc grpc.ClientConnInterface
}

func NewMeshpipeDataClient(cc grpc.ClientConnInterface) MeshpipeDataClient {
	return &meshpipeDataClient{cc}
}

func (c *meshpipeDataClient) GetDashboardStats(ctx context.Context, in *DashboardRequest, opts ...grpc.CallOption) (*DashboardResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DashboardResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_GetDashboardStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) ListPackets(ctx context.Context, in *ListPacketsRequest, opts ...grpc.CallOption) (*ListPacketsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPacketsResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_ListPackets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) StreamPackets(ctx context.Context, in *ListPacketsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Packet], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MeshpipeData_ServiceDesc.Streams[0], MeshpipeData_StreamPackets_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ListPacketsRequest, Packet]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MeshpipeData_StreamPacketsClient = grpc.ServerStreamingClient[Packet]

func (c *meshpipeDataClient) ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (*ListNodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNodesResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_ListNodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*GetNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNodeResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_GetNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) GetGatewayStats(ctx context.Context, in *GatewayFilter, opts ...grpc.CallOption) (*GatewayStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GatewayStatsResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_GetGatewayStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) ListLinks(ctx context.Context, in *ListLinksRequest, opts ...grpc.CallOption) (*ListLinksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLinksResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_ListLinks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) ListTraceroutes(ctx context.Context, in *ListTraceroutesRequest, opts ...grpc.CallOption) (*ListTraceroutesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTraceroutesResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_ListTraceroutes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) ListRangeTests(ctx context.Context, in *ListRangeTestsRequest, opts ...grpc.CallOption) (*ListRangeTestsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRangeTestsResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_ListRangeTests_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) ListStoreForward(ctx context.Context, in *ListStoreForwardRequest, opts ...grpc.CallOption) (*ListStoreForwardResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListStoreForwardResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_ListStoreForward_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) ListPaxcounter(ctx context.Context, in *ListPaxcounterRequest, opts ...grpc.CallOption) (*ListPaxcounterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPaxcounterResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_ListPaxcounter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) ListNodeLocations(ctx context.Context, in *ListNodeLocationsRequest, opts ...grpc.CallOption) (*ListNodeLocationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNodeLocationsResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_ListNodeLocations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) GetChatWindow(ctx context.Context, in *GetChatWindowRequest, opts ...grpc.CallOption) (*GetChatWindowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetChatWindowResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_GetChatWindow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) GetNodeAnalytics(ctx context.Context, in *GetNodeAnalyticsRequest, opts ...grpc.CallOption) (*GetNodeAnalyticsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNodeAnalyticsResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_GetNodeAnalytics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) GetGatewayOverview(ctx context.Context, in *GetGatewayOverviewRequest, opts ...grpc.CallOption) (*GetGatewayOverviewResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGatewayOverviewResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_GetGatewayOverview_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) GetNetworkTopology(ctx context.Context, in *NetworkTopologyRequest, opts ...grpc.CallOption) (*NetworkTopologyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NetworkTopologyResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_GetNetworkTopology_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) GetLongestLinksAnalysis(ctx context.Context, in *LongestLinksRequest, opts ...grpc.CallOption) (*LongestLinksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LongestLinksResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_GetLongestLinksAnalysis_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) GetGatewayComparison(ctx context.Context, in *GatewayComparisonRequest, opts ...grpc.CallOption) (*GatewayComparisonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GatewayComparisonResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_GetGatewayComparison_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) ListGatewayCandidates(ctx context.Context, in *GatewayCandidatesRequest, opts ...grpc.CallOption) (*GatewayCandidatesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GatewayCandidatesResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_ListGatewayCandidates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) GetAnalyticsSummary(ctx context.Context, in *GetAnalyticsSummaryRequest, opts ...grpc.CallOption) (*GetAnalyticsSummaryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAnalyticsSummaryResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_GetAnalyticsSummary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) ListTraceroutePackets(ctx context.Context, in *ListTraceroutePacketsRequest, opts ...grpc.CallOption) (*ListTraceroutePacketsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTraceroutePacketsResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_ListTraceroutePackets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) GetTracerouteDetails(ctx context.Context, in *GetTracerouteDetailsRequest, opts ...grpc.CallOption) (*GetTracerouteDetailsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTracerouteDetailsResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_GetTracerouteDetails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) ListTracerouteHops(ctx context.Context, in *ListTracerouteHopsRequest, opts ...grpc.CallOption) (*ListTracerouteHopsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTracerouteHopsResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_ListTracerouteHops_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) GetTracerouteGraph(ctx context.Context, in *TracerouteGraphRequest, opts ...grpc.CallOption) (*TracerouteGraphResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TracerouteGraphResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_GetTracerouteGraph_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) ListNodeDirectReceptions(ctx context.Context, in *ListNodeDirectReceptionsRequest, opts ...grpc.CallOption) (*ListNodeDirectReceptionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNodeDirectReceptionsResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_ListNodeDirectReceptions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) ListNodeNames(ctx context.Context, in *ListNodeNamesRequest, opts ...grpc.CallOption) (*ListNodeNamesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNodeNamesResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_ListNodeNames_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) ListPrimaryChannels(ctx context.Context, in *ListPrimaryChannelsRequest, opts ...grpc.CallOption) (*ListPrimaryChannelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPrimaryChannelsResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_ListPrimaryChannels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) Healthz(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_Healthz_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *meshpipeDataClient) GetVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*VersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, MeshpipeData_GetVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MeshpipeDataServer is the server API for MeshpipeData service.
// All implementations must embed UnimplementedMeshpipeDataServer
// for forward compatibility.
type MeshpipeDataServer interface {
	GetDashboardStats(context.Context, *DashboardRequest) (*DashboardResponse, error)
	ListPackets(context.Context, *ListPacketsRequest) (*ListPacketsResponse, error)
	StreamPackets(*ListPacketsRequest, grpc.ServerStreamingServer[Packet]) error
	ListNodes(context.Context, *ListNodesRequest) (*ListNodesResponse, error)
	GetNode(context.Context, *GetNodeRequest) (*GetNodeResponse, error)
	GetGatewayStats(context.Context, *GatewayFilter) (*GatewayStatsResponse, error)
	ListLinks(context.Context, *ListLinksRequest) (*ListLinksResponse, error)
	ListTraceroutes(context.Context, *ListTraceroutesRequest) (*ListTraceroutesResponse, error)
	ListRangeTests(context.Context, *ListRangeTestsRequest) (*ListRangeTestsResponse, error)
	ListStoreForward(context.Context, *ListStoreForwardRequest) (*ListStoreForwardResponse, error)
	ListPaxcounter(context.Context, *ListPaxcounterRequest) (*ListPaxcounterResponse, error)
	ListNodeLocations(context.Context, *ListNodeLocationsRequest) (*ListNodeLocationsResponse, error)
	GetChatWindow(context.Context, *GetChatWindowRequest) (*GetChatWindowResponse, error)
	GetNodeAnalytics(context.Context, *GetNodeAnalyticsRequest) (*GetNodeAnalyticsResponse, error)
	GetGatewayOverview(context.Context, *GetGatewayOverviewRequest) (*GetGatewayOverviewResponse, error)
	GetNetworkTopology(context.Context, *NetworkTopologyRequest) (*NetworkTopologyResponse, error)
	GetLongestLinksAnalysis(context.Context, *LongestLinksRequest) (*LongestLinksResponse, error)
	GetGatewayComparison(context.Context, *GatewayComparisonRequest) (*GatewayComparisonResponse, error)
	ListGatewayCandidates(context.Context, *GatewayCandidatesRequest) (*GatewayCandidatesResponse, error)
	GetAnalyticsSummary(context.Context, *GetAnalyticsSummaryRequest) (*GetAnalyticsSummaryResponse, error)
	ListTraceroutePackets(context.Context, *ListTraceroutePacketsRequest) (*ListTraceroutePacketsResponse, error)
	GetTracerouteDetails(context.Context, *GetTracerouteDetailsRequest) (*GetTracerouteDetailsResponse, error)
	ListTracerouteHops(context.Context, *ListTracerouteHopsRequest) (*ListTracerouteHopsResponse, error)
	GetTracerouteGraph(context.Context, *TracerouteGraphRequest) (*TracerouteGraphResponse, error)
	ListNodeDirectReceptions(context.Context, *ListNodeDirectReceptionsRequest) (*ListNodeDirectReceptionsResponse, error)
	ListNodeNames(context.Context, *ListNodeNamesRequest) (*ListNodeNamesResponse, error)
	ListPrimaryChannels(context.Context, *ListPrimaryChannelsRequest) (*ListPrimaryChannelsResponse, error)
	Healthz(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	GetVersion(context.Context, *GetVersionRequest) (*VersionResponse, error)
	mustEmbedUnimplementedMeshpipeDataServer()
}

// UnimplementedMeshpipeDataServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMeshpipeDataServer struct{}

func (UnimplementedMeshpipeDataServer) GetDashboardStats(context.Context, *DashboardRequest) (*DashboardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDashboardStats not implemented")
}
func (UnimplementedMeshpipeDataServer) ListPackets(context.Context, *ListPacketsRequest) (*ListPacketsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPackets not implemented")
}
func (UnimplementedMeshpipeDataServer) StreamPackets(*ListPacketsRequest, grpc.ServerStreamingServer[Packet]) error {
	return status.Errorf(codes.Unimplemented, "method StreamPackets not implemented")
}
func (UnimplementedMeshpipeDataServer) ListNodes(context.Context, *ListNodesRequest) (*ListNodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNodes not implemented")
}
func (UnimplementedMeshpipeDataServer) GetNode(context.Context, *GetNodeRequest) (*GetNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNode not implemented")
}
func (UnimplementedMeshpipeDataServer) GetGatewayStats(context.Context, *GatewayFilter) (*GatewayStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGatewayStats not implemented")
}
func (UnimplementedMeshpipeDataServer) ListLinks(context.Context, *ListLinksRequest) (*ListLinksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLinks not implemented")
}
func (UnimplementedMeshpipeDataServer) ListTraceroutes(context.Context, *ListTraceroutesRequest) (*ListTraceroutesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTraceroutes not implemented")
}
func (UnimplementedMeshpipeDataServer) ListRangeTests(context.Context, *ListRangeTestsRequest) (*ListRangeTestsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRangeTests not implemented")
}
func (UnimplementedMeshpipeDataServer) ListStoreForward(context.Context, *ListStoreForwardRequest) (*ListStoreForwardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStoreForward not implemented")
}
func (UnimplementedMeshpipeDataServer) ListPaxcounter(context.Context, *ListPaxcounterRequest) (*ListPaxcounterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPaxcounter not implemented")
}
func (UnimplementedMeshpipeDataServer) ListNodeLocations(context.Context, *ListNodeLocationsRequest) (*ListNodeLocationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNodeLocations not implemented")
}
func (UnimplementedMeshpipeDataServer) GetChatWindow(context.Context, *GetChatWindowRequest) (*GetChatWindowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChatWindow not implemented")
}
func (UnimplementedMeshpipeDataServer) GetNodeAnalytics(context.Context, *GetNodeAnalyticsRequest) (*GetNodeAnalyticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeAnalytics not implemented")
}
func (UnimplementedMeshpipeDataServer) GetGatewayOverview(context.Context, *GetGatewayOverviewRequest) (*GetGatewayOverviewResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGatewayOverview not implemented")
}
func (UnimplementedMeshpipeDataServer) GetNetworkTopology(context.Context, *NetworkTopologyRequest) (*NetworkTopologyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNetworkTopology not implemented")
}
func (UnimplementedMeshpipeDataServer) GetLongestLinksAnalysis(context.Context, *LongestLinksRequest) (*LongestLinksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLongestLinksAnalysis not implemented")
}
func (UnimplementedMeshpipeDataServer) GetGatewayComparison(context.Context, *GatewayComparisonRequest) (*GatewayComparisonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGatewayComparison not implemented")
}
func (UnimplementedMeshpipeDataServer) ListGatewayCandidates(context.Context, *GatewayCandidatesRequest) (*GatewayCandidatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGatewayCandidates not implemented")
}
func (UnimplementedMeshpipeDataServer) GetAnalyticsSummary(context.Context, *GetAnalyticsSummaryRequest) (*GetAnalyticsSummaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAnalyticsSummary not implemented")
}
func (UnimplementedMeshpipeDataServer) ListTraceroutePackets(context.Context, *ListTraceroutePacketsRequest) (*ListTraceroutePacketsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTraceroutePackets not implemented")
}
func (UnimplementedMeshpipeDataServer) GetTracerouteDetails(context.Context, *GetTracerouteDetailsRequest) (*GetTracerouteDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTracerouteDetails not implemented")
}
func (UnimplementedMeshpipeDataServer) ListTracerouteHops(context.Context, *ListTracerouteHopsRequest) (*ListTracerouteHopsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTracerouteHops not implemented")
}
func (UnimplementedMeshpipeDataServer) GetTracerouteGraph(context.Context, *TracerouteGraphRequest) (*TracerouteGraphResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTracerouteGraph not implemented")
}
func (UnimplementedMeshpipeDataServer) ListNodeDirectReceptions(context.Context, *ListNodeDirectReceptionsRequest) (*ListNodeDirectReceptionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNodeDirectReceptions not implemented")
}
func (UnimplementedMeshpipeDataServer) ListNodeNames(context.Context, *ListNodeNamesRequest) (*ListNodeNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNodeNames not implemented")
}
func (UnimplementedMeshpipeDataServer) ListPrimaryChannels(context.Context, *ListPrimaryChannelsRequest) (*ListPrimaryChannelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPrimaryChannels not implemented")
}
func (UnimplementedMeshpipeDataServer) Healthz(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Healthz not implemented")
}
func (UnimplementedMeshpipeDataServer) GetVersion(context.Context, *GetVersionRequest) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedMeshpipeDataServer) mustEmbedUnimplementedMeshpipeDataServer() {}
func (UnimplementedMeshpipeDataServer) testEmbeddedByValue()                      {}

// UnsafeMeshpipeDataServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MeshpipeDataServer will
// result in compilation errors.
type UnsafeMeshpipeDataServer interface {
	mustEmbedUnimplementedMeshpipeDataServer()
}

func RegisterMeshpipeDataServer(s grpc.ServiceRegistrar, srv MeshpipeDataServer) {
	// If the following call pancis, it indicates UnimplementedMeshpipeDataServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MeshpipeData_ServiceDesc, srv)
}

func _MeshpipeData_GetDashboardStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DashboardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).GetDashboardStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_GetDashboardStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).GetDashboardStats(ctx, req.(*DashboardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_ListPackets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPacketsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).ListPackets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_ListPackets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).ListPackets(ctx, req.(*ListPacketsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_StreamPackets_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListPacketsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MeshpipeDataServer).StreamPackets(m, &grpc.GenericServerStream[ListPacketsRequest, Packet]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MeshpipeData_StreamPacketsServer = grpc.ServerStreamingServer[Packet]

func _MeshpipeData_ListNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).ListNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_ListNodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).ListNodes(ctx, req.(*ListNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).GetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_GetNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).GetNode(ctx, req.(*GetNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_GetGatewayStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GatewayFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).GetGatewayStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_GetGatewayStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).GetGatewayStats(ctx, req.(*GatewayFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_ListLinks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLinksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).ListLinks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_ListLinks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).ListLinks(ctx, req.(*ListLinksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_ListTraceroutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTraceroutesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).ListTraceroutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_ListTraceroutes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).ListTraceroutes(ctx, req.(*ListTraceroutesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_ListRangeTests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRangeTestsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).ListRangeTests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_ListRangeTests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).ListRangeTests(ctx, req.(*ListRangeTestsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_ListStoreForward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStoreForwardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).ListStoreForward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_ListStoreForward_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).ListStoreForward(ctx, req.(*ListStoreForwardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_ListPaxcounter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPaxcounterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).ListPaxcounter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_ListPaxcounter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).ListPaxcounter(ctx, req.(*ListPaxcounterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_ListNodeLocations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNodeLocationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).ListNodeLocations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_ListNodeLocations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).ListNodeLocations(ctx, req.(*ListNodeLocationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_GetChatWindow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChatWindowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).GetChatWindow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_GetChatWindow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).GetChatWindow(ctx, req.(*GetChatWindowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_GetNodeAnalytics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeAnalyticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).GetNodeAnalytics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_GetNodeAnalytics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).GetNodeAnalytics(ctx, req.(*GetNodeAnalyticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_GetGatewayOverview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGatewayOverviewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).GetGatewayOverview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_GetGatewayOverview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).GetGatewayOverview(ctx, req.(*GetGatewayOverviewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_GetNetworkTopology_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkTopologyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).GetNetworkTopology(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_GetNetworkTopology_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).GetNetworkTopology(ctx, req.(*NetworkTopologyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_GetLongestLinksAnalysis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LongestLinksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).GetLongestLinksAnalysis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_GetLongestLinksAnalysis_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).GetLongestLinksAnalysis(ctx, req.(*LongestLinksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_GetGatewayComparison_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GatewayComparisonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).GetGatewayComparison(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_GetGatewayComparison_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).GetGatewayComparison(ctx, req.(*GatewayComparisonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_ListGatewayCandidates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GatewayCandidatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).ListGatewayCandidates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_ListGatewayCandidates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).ListGatewayCandidates(ctx, req.(*GatewayCandidatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_GetAnalyticsSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAnalyticsSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).GetAnalyticsSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_GetAnalyticsSummary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).GetAnalyticsSummary(ctx, req.(*GetAnalyticsSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_ListTraceroutePackets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTraceroutePacketsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).ListTraceroutePackets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_ListTraceroutePackets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).ListTraceroutePackets(ctx, req.(*ListTraceroutePacketsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_GetTracerouteDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTracerouteDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).GetTracerouteDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_GetTracerouteDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).GetTracerouteDetails(ctx, req.(*GetTracerouteDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_ListTracerouteHops_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTracerouteHopsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).ListTracerouteHops(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_ListTracerouteHops_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).ListTracerouteHops(ctx, req.(*ListTracerouteHopsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_GetTracerouteGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TracerouteGraphRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).GetTracerouteGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_GetTracerouteGraph_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).GetTracerouteGraph(ctx, req.(*TracerouteGraphRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_ListNodeDirectReceptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNodeDirectReceptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).ListNodeDirectReceptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_ListNodeDirectReceptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).ListNodeDirectReceptions(ctx, req.(*ListNodeDirectReceptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_ListNodeNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNodeNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).ListNodeNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_ListNodeNames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).ListNodeNames(ctx, req.(*ListNodeNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_ListPrimaryChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPrimaryChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).ListPrimaryChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_ListPrimaryChannels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).ListPrimaryChannels(ctx, req.(*ListPrimaryChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_Healthz_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).Healthz(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_Healthz_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).Healthz(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeshpipeData_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshpipeDataServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeshpipeData_GetVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshpipeDataServer).GetVersion(ctx, req.(*GetVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MeshpipeData_ServiceDesc is the grpc.ServiceDesc for MeshpipeData service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MeshpipeData_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "meshpipe.v1.MeshpipeData",
	HandlerType: (*MeshpipeDataServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDashboardStats",
			Handler:    _MeshpipeData_GetDashboardStats_Handler,
		},
		{
			MethodName: "ListPackets",
			Handler:    _MeshpipeData_ListPackets_Handler,
		},
		{
			MethodName: "ListNodes",
			Handler:    _MeshpipeData_ListNodes_Handler,
		},
		{
			MethodName: "GetNode",
			Handler:    _MeshpipeData_GetNode_Handler,
		},
		{
			MethodName: "GetGatewayStats",
			Handler:    _MeshpipeData_GetGatewayStats_Handler,
		},
		{
			MethodName: "ListLinks",
			Handler:    _MeshpipeData_ListLinks_Handler,
		},
		{
			MethodName: "ListTraceroutes",
			Handler:    _MeshpipeData_ListTraceroutes_Handler,
		},
		{
			MethodName: "ListRangeTests",
			Handler:    _MeshpipeData_ListRangeTests_Handler,
		},
		{
			MethodName: "ListStoreForward",
			Handler:    _MeshpipeData_ListStoreForward_Handler,
		},
		{
			MethodName: "ListPaxcounter",
			Handler:    _MeshpipeData_ListPaxcounter_Handler,
		},
		{
			MethodName: "ListNodeLocations",
			Handler:    _MeshpipeData_ListNodeLocations_Handler,
		},
		{
			MethodName: "GetChatWindow",
			Handler:    _MeshpipeData_GetChatWindow_Handler,
		},
		{
			MethodName: "GetNodeAnalytics",
			Handler:    _MeshpipeData_GetNodeAnalytics_Handler,
		},
		{
			MethodName: "GetGatewayOverview",
			Handler:    _MeshpipeData_GetGatewayOverview_Handler,
		},
		{
			MethodName: "GetNetworkTopology",
			Handler:    _MeshpipeData_GetNetworkTopology_Handler,
		},
		{
			MethodName: "GetLongestLinksAnalysis",
			Handler:    _MeshpipeData_GetLongestLinksAnalysis_Handler,
		},
		{
			MethodName: "GetGatewayComparison",
			Handler:    _MeshpipeData_GetGatewayComparison_Handler,
		},
		{
			MethodName: "ListGatewayCandidates",
			Handler:    _MeshpipeData_ListGatewayCandidates_Handler,
		},
		{
			MethodName: "GetAnalyticsSummary",
			Handler:    _MeshpipeData_GetAnalyticsSummary_Handler,
		},
		{
			MethodName: "ListTraceroutePackets",
			Handler:    _MeshpipeData_ListTraceroutePackets_Handler,
		},
		{
			MethodName: "GetTracerouteDetails",
			Handler:    _MeshpipeData_GetTracerouteDetails_Handler,
		},
		{
			MethodName: "ListTracerouteHops",
			Handler:    _MeshpipeData_ListTracerouteHops_Handler,
		},
		{
			MethodName: "GetTracerouteGraph",
			Handler:    _MeshpipeData_GetTracerouteGraph_Handler,
		},
		{
			MethodName: "ListNodeDirectReceptions",
			Handler:    _MeshpipeData_ListNodeDirectReceptions_Handler,
		},
		{
			MethodName: "ListNodeNames",
			Handler:    _MeshpipeData_ListNodeNames_Handler,
		},
		{
			MethodName: "ListPrimaryChannels",
			Handler:    _MeshpipeData_ListPrimaryChannels_Handler,
		},
		{
			MethodName: "Healthz",
			Handler:    _MeshpipeData_Healthz_Handler,
		},
		{
			MethodName: "GetVersion",
			Handler:    _MeshpipeData_GetVersion_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamPackets",
			Handler:       _MeshpipeData_StreamPackets_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/meshpipe/v1/data.proto",
}
